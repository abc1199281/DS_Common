// BinaryTree.h

#ifndef __DS_COMMON_BINARY_TREE_H__
#define __DS_COMMON_BINARY_TREE_H__

/* Information */
//====================================================================================================

/*!
*  @file   BinaryTree.h
*
*  @brief  The Definition of BinaryTree and its Node Template
*
*  @author Po-Wei Huang
*
*  @date   2021/04/24
*/

//====================================================================================================


/* Header */
//====================================================================================================

#include <iostream>
#include <stack>
#include <condition_variable>

#include <DS_Common/LibSetting/LibSetting.h>
//====================================================================================================


/* Definition */
//====================================================================================================

namespace DS_Common {

	//--------------------------------------------------------------------------------------------
	/*!
	*  @brief      Tree Node
	*
	*/
	template <class T>
	struct BTreeNode
	{
		T val;
		BTreeNode *left;
		BTreeNode *right;
		BTreeNode() : left(nullptr), right(nullptr) {}
		BTreeNode(T x) : val(x), left(nullptr), right(nullptr) {}
		BTreeNode(T x, BTreeNode<T> *left, BTreeNode<T> *right) : val(x), left(left), right(right) {}
	};
	//--------------------------------------------------------------------------------------------

	//--------------------------------------------------------------------------------------------
	/*!
	*  @brief      Binary Tree
	*
	*/
	template<typename T>
	class  BinaryTree
	{
	private:
		BTreeNode<T>* root;
		using visit_callback = std::function< void(BTreeNode<T>* cur) >;
		visit_callback visit_call_back_func;
	public:
		
		//-----------------------------------------------------------------------------------------
		/*!
		*  @brief      Default Constructor
		*
		*/
		BinaryTree() {}
		//-----------------------------------------------------------------------------------------

		//-----------------------------------------------------------------------------------------
		/*!
		*  @brief      Constructor with Root
		*
		*/
		BinaryTree(BTreeNode<T>* r) : root(r) { 
			visit_call_back_func = [](BTreeNode<T>* cur)-> void {std::cout << cur->val << std::endl; };
		}
		//-----------------------------------------------------------------------------------------

		//-----------------------------------------------------------------------------------------
		/*!
		*  @brief      In order Traversal
		*
		*/
		void inorder(BTreeNode<T>* cur);
		//-----------------------------------------------------------------------------------------

		//-----------------------------------------------------------------------------------------
		/*!
		*  @brief      In order Traversal
		*
		*/
		void inorder() { inorder(root); };
		//-----------------------------------------------------------------------------------------

		//-----------------------------------------------------------------------------------------
		/*!
		*  @brief      Pre order Traversal
		*
		*/
		void preorder(BTreeNode<T>* cur);
		//-----------------------------------------------------------------------------------------

		//-----------------------------------------------------------------------------------------
		/*!
		*  @brief      Pre order Traversal
		*
		*/
		void preorder() { preorder(root); };
		//-----------------------------------------------------------------------------------------

		//-----------------------------------------------------------------------------------------
		/*!
		*  @brief      Pre order Traversal
		*
		*/
		void postorder(BTreeNode<T>* cur);
		//-----------------------------------------------------------------------------------------

		//-----------------------------------------------------------------------------------------
		/*!
		*  @brief      Pre order Traversal
		*
		*/
		void postorder() { postorder(root); };
		//-----------------------------------------------------------------------------------------


		//-----------------------------------------------------------------------------------------
		/*!
		*  @brief      iterative_in_order
		*
		*/
		void iterative_in_order(BTreeNode<T>* cur);
		//-----------------------------------------------------------------------------------------
		//-----------------------------------------------------------------------------------------
		/*!
		*  @brief      iterative_in_order
		*
		*/
		void iterative_in_order() { iterative_in_order(root); };
		//-----------------------------------------------------------------------------------------

		//-----------------------------------------------------------------------------------------
		/*!
		*  @brief      set call back function
		*
		*/
		void set_callback(visit_callback  fun) {
			visit_call_back_func = fun;
		}
		//-----------------------------------------------------------------------------------------



		//-----------------------------------------------------------------------------------------
		/*!
		*  @brief      Check is Equal
		*
		*/
		bool isEqual(BinaryTree<T>* r2) { return true; };
		//-----------------------------------------------------------------------------------------

	};
	//--------------------------------------------------------------------------------------------
}



//====================================================================================================


/* Function */
//====================================================================================================

namespace DS_Common {
	//-----------------------------------------------------------------------------------------
	template<typename T>
	void BinaryTree<T>::inorder(BTreeNode<T>* cur)
	{
		if (!cur) return;
		inorder(cur->left);
		visit_call_back_func(cur);
		inorder(cur->right);
	}
	//-----------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------
	template<typename T>
	void BinaryTree<T>::postorder(BTreeNode<T>* cur)
	{
		if (!cur) return;
		postorder(cur->left);
		postorder(cur->right);
		visit_call_back_func(cur);
	}
	//-----------------------------------------------------------------------------------------

	//-----------------------------------------------------------------------------------------
	template<typename T>
	void BinaryTree<T>::preorder(BTreeNode<T>* cur)
	{
		if (!cur) return;
		visit_call_back_func(cur);
		preorder(cur->left);
		preorder(cur->right);
	}
	//-----------------------------------------------------------------------------------------


	//-----------------------------------------------------------------------------------------
	template<typename T>
	void BinaryTree<T>::iterative_in_order(BTreeNode<T>* root)
	{
		if (!root) return;
		std::stack<BTreeNode<T>*> stk;

		BTreeNode<T>* cur=root;
		while (1)
		{
			while (cur) {
				stk.push(cur);
				cur = cur->left;
			}
			if (stk.empty()) return;

			cur = stk.top(); 
			stk.pop();
			visit_call_back_func(cur);
			
			cur = cur->right;
		}
	}
	//-----------------------------------------------------------------------------------------
}
//====================================================================================================

#endif /* __DS_COMMON_BINARY_TREE_H__ */
